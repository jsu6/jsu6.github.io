<!doctype html>
<meta charset="utf-8" />
<title>Animation Timing Fingerprint (10 rounds)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  body { padding: 18px; max-width: 900px; }
  h1 { font-size: 20px; margin-bottom: 10px; }
  button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; background: #fafafa; cursor: pointer; }
  pre { background: #fafafa; border: 1px solid #ddd; padding: 8px; overflow: auto; max-height: 260px; }
  table { border-collapse: collapse; width: 100%; margin-top: 12px; font-size: 13px; }
  th, td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; }
  th { background: #f5f5f5; }
  .muted { color: #666; font-size: 12px; }
</style>

<h1>Animation Timing Fingerprint</h1>
<p class="muted">
Runs 10 rounds using <code>Animation.startTime</code>, <code>updatePlaybackRate()</code>,
<code>AnimationEffect.getComputedTiming()</code>, <code>getTiming()</code>,
<code>updateTiming()</code>, and <code>AnimationTimeline.getCurrentTime()</code>.
Measures average duration and stability across rounds.
</p>

<button id="runBtn">Run 10 Rounds</button>
<span id="status" class="muted">idle</span>

<table id="table">
  <thead>
    <tr><th>Round</th><th>Duration (ms)</th><th>Mean Frame Δ</th><th>Std</th><th>Hash</th></tr>
  </thead>
  <tbody></tbody>
</table>

<h3>Fingerprint Summary</h3>
<pre id="out"></pre>

<script>
(async()=>{
const $ = s=>document.querySelector(s);
const runBtn=$("#runBtn"),status=$("#status"),tbody=$("#table tbody"),out=$("#out");

runBtn.onclick=async()=>{
  runBtn.disabled=true; tbody.innerHTML=""; out.textContent=""; status.textContent="running…";

  const rounds=10;
  const hashes=[], times=[];
  for(let i=0;i<rounds;i++){
    const res = await singleRun(i+1);
    hashes.push(res.hash);
    times.push(res.stats.mean);
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${i+1}</td><td>${round(res.totalTime)}</td><td>${round(res.stats.mean)}</td><td>${round(res.stats.std)}</td><td style="font-family:monospace">${res.hash.slice(0,16)}…</td>`;
    tbody.appendChild(tr);
    await sleep(300);
  }

  const stability = computeStability(hashes);
  const mean = meanVal(times), std = stdVal(times,mean);
  out.textContent = JSON.stringify({ stability, mean, std, hashes }, null, 2);
  status.textContent = "done";
  runBtn.disabled=false;
};

async function singleRun(roundNo){
  const box = document.createElement("div");
  box.style.width="20px"; box.style.height="20px";
  box.style.background="#69f"; box.style.position="absolute"; box.style.top="0"; box.style.left="0";
  document.body.appendChild(box);

  const keyframes=[{transform:'translateX(0px)'},{transform:'translateX(100px)'}];
  const options={duration:1000,iterations:1,easing:'linear'};
  const anim = box.animate(keyframes,options);

  // access Animation.startTime, set playback rate
  anim.startTime = document.timeline.getCurrentTime();
  anim.updatePlaybackRate(1.0 + (Math.random()*0.2 - 0.1)); // small variation

  const deltas=[], start=document.timeline.getCurrentTime();
  let last=start;

  // read timing structs
  const timing0 = anim.effect.getTiming();
  anim.effect.updateTiming({delay:(timing0.delay||0)+0.1}); // micro adjustment
  const comp0 = anim.effect.getComputedTiming();

  await new Promise(resolve=>{
    function tick(t){
      const tl=document.timeline.getCurrentTime();
      const comp=anim.effect.getComputedTiming();
      deltas.push(tl-last);
      last=tl;
      if(tl-start<1000) requestAnimationFrame(tick);
      else resolve();
    }
    requestAnimationFrame(tick);
  });

  const total=document.timeline.getCurrentTime()-start;
  const stats=calcStats(deltas);
  const obj={ startTime:anim.startTime, duration:total, mean:stats.mean, std:stats.std,
              computedTiming:compact(comp0), timing:compact(timing0)};
  const hash=await hashObj(obj);

  anim.cancel(); box.remove();
  return { totalTime: total, stats, hash };
}

function calcStats(a){
  const arr=a.filter(x=>isFinite(x));const n=arr.length;
  const mean=arr.reduce((a,b)=>a+b,0)/n;
  const v=arr.reduce((a,b)=>a+(b-mean)**2,0)/n;
  const std=Math.sqrt(v);
  return{mean,std,n};
}

async function hashObj(o){
  const enc=new TextEncoder().encode(JSON.stringify(o));
  const buf=await crypto.subtle.digest("SHA-256",enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
}

function computeStability(hs){
  if(hs.length<2)return 100;
  const base=hs[0].split("");let diff=0,total=0;
  for(let i=1;i<hs.length;i++){
    const cur=hs[i].split("");
    for(let j=0;j<base.length;j++){total++; if(base[j]!==cur[j]) diff++;}
  }
  return 100*(1-diff/total);
}
function meanVal(a){return a.reduce((x,y)=>x+y,0)/a.length;}
function stdVal(a,m){return Math.sqrt(a.reduce((x,y)=>x+(y-m)**2,0)/a.length);}
function compact(o){if(!o)return null;const pick={delay:o.delay,duration:o.duration,endDelay:o.endDelay,fill:o.fill,iterations:o.iterations,easing:o.easing};return pick;}
function round(x){return x?Math.round(x*1000)/1000:"";}
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
})();
</script>
