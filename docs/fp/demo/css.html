<!doctype html>
<meta charset="utf-8" />
<title>CSS Typed OM + CSSAnimation Fingerprinting PoC</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; padding: 18px; }
  h1 { margin: 0 0 8px; }
  button { padding: 8px 12px; font: inherit; }
  table { border-collapse: collapse; margin-top: 12px; width: 100%; max-width: 1000px; }
  th, td { border: 1px solid #ddd; padding: 6px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .ok { color: #0a7d27; }
  .no { color: #b00020; }
  pre { background: #f7f7f7; padding: 10px; border: 1px solid #eee; overflow:auto; }
</style>

<h1>CSS Typed OM + CSSAnimation Probe</h1>
<p>Click “Run” to query the APIs and display the resulting values.</p>
<button id="run">Run</button>

<h3>Results</h3>
<table id="tbl">
  <thead>
    <tr><th>API</th><th>Supported</th><th>Result / Notes</th></tr>
  </thead>
  <tbody></tbody>
</table>

<h3>Fingerprint (SHA-256 of result vector)</h3>
<pre id="fp">—</pre>

<script>
(async () => {
  const $ = sel => document.querySelector(sel);
  const tbody = $("#tbl tbody");
  const fpOut = $("#fp");
  const btn = $("#run");

  function addRow(api, supported, value) {
    const tr = document.createElement("tr");
    const td1 = document.createElement("td"); td1.textContent = api;
    const td2 = document.createElement("td");
    td2.textContent = supported ? "yes" : "no";
    td2.className = supported ? "ok" : "no";
    const td3 = document.createElement("td"); td3.textContent = value;
    tr.append(td1, td2, td3);
    tbody.appendChild(tr);
  }

  function tryCall(api, fn) {
    try {
      const val = fn();
      addRow(api, true, stringify(val));
      return ["1", String(val)];
    } catch (e) {
      addRow(api, false, (e && e.message) ? ("ERR: " + e.message) : "unsupported/throws");
      return ["0", "err"];
    }
  }

  const precision = n => (typeof n === "number") ? Number(n.toFixed(6)) : n;
  const stringify = v => {
    if (v && typeof v === "object") {
      // best-effort stable-ish view
      if ("value" in v && "unit" in v) return `${precision(v.value)} ${v.unit}`;
      try { return JSON.stringify(v); } catch { return String(v); }
    }
    return String(v);
  };

  async function sha256Hex(text) {
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest("SHA-256", enc.encode(text));
    return [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2, "0")).join("");
  }

  function supports(ctorName) {
    try { return (ctorName in window) && typeof window[ctorName] !== "undefined"; }
    catch { return false; }
  }

  // Build a tiny CSS animation from CSS (so getAnimations() yields a CSSAnimation)
  function probeCSSAnimationName() {
    const id = "fp_anim_" + Math.random().toString(36).slice(2);
    const style = document.createElement("style");
    style.textContent = `
      @keyframes ${id} { from { opacity: 0.9; } to { opacity: 0.91; } }
      .fp-anim-probe { animation: ${id} 1.1s ease-in-out 1 paused; }
    `;
    document.head.appendChild(style);

    const div = document.createElement("div");
    div.className = "fp-anim-probe";
    document.body.appendChild(div);

    const anims = div.getAnimations ? div.getAnimations() : [];
    let name = "n/a";
    for (const a of anims) {
      if ("animationName" in a) { // CSSAnimation specific
        name = a.animationName;
        break;
      }
    }

    div.remove(); style.remove();
    return name;
  }

  function probeCSSNumeric() {
    const out = {};

    // Guard for Typed OM
    const hasCSS = typeof CSS !== "undefined" && CSS && "px" in CSS;
    if (!hasCSS || typeof CSSNumericValue === "undefined") {
      addRow("CSSNumericValue (global)", false, "Typed OM not available");
      return out;
    }
    addRow("CSSNumericValue (global)", true, "Typed OM available");

    // Basic unit values
    const px10 = CSS.px(10);
    const px4  = CSS.px(4);
    const cm1  = CSS.cm ? CSS.cm(1) : null;
    const deg90 = CSS.deg ? CSS.deg(90) : null;
    const rad1  = CSS.rad ? CSS.rad(1) : null;

    // Instance ops: add/sub/mul/div
    tryCall("CSSNumericValue.add", () => px10.add(px4).to("px").value);
    tryCall("CSSNumericValue.sub", () => px10.sub(px4).to("px").value);
    tryCall("CSSNumericValue.mul", () => px10.mul(2).to("px").value);
    tryCall("CSSNumericValue.div", () => px10.div(4).to("px").value);

    // Unit conversions with to()
    if (cm1) {
      tryCall("CSSNumericValue.to (cm→px)", () => precision(cm1.to("px").value));
    } else {
      addRow("CSSNumericValue.to (cm→px)", false, "CSS.cm not available");
    }

    if (deg90) {
      tryCall("CSSNumericValue.to (deg→rad)", () => precision(deg90.to("rad").value));
    } else {
      addRow("CSSNumericValue.to (deg→rad)", false, "CSS.deg not available");
    }

    if (rad1) {
      tryCall("CSSNumericValue.to (rad→deg)", () => precision(rad1.to("deg").value));
    } else {
      addRow("CSSNumericValue.to (rad→deg)", false, "CSS.rad not available");
    }

    // toSum() often throws unless units are compatible in the current engine
    tryCall("CSSNumericValue.toSum('px')", () => px10.toSum("px").to("px").value);

    // Static max/min across same units (if implemented)
    if ("max" in CSSNumericValue) {
      tryCall("CSSNumericValue.max(px10, px4)", () =>
        CSSNumericValue.max(px10, px4).to("px").value
      );
    } else {
      addRow("CSSNumericValue.max", false, "not implemented");
    }

    if ("min" in CSSNumericValue) {
      tryCall("CSSNumericValue.min(px10, px4)", () =>
        CSSNumericValue.min(px10, px4).to("px").value
      );
    } else {
      addRow("CSSNumericValue.min", false, "not implemented");
    }

    return out;
  }

  function probeTransforms() {
    // CSSTransformValue.is2D
    if (!supports("CSSTransformValue")) {
      addRow("CSSTransformValue.is2D", false, "CSSTransformValue unavailable");
    } else {
      // Prefer constructors if available; otherwise fallback via computed style parsing
      if (supports("CSSTranslate")) {
        const t2d = new CSSTranslate(CSS.px(5), CSS.px(7));
        const v2d = new CSSTransformValue([t2d]);
        addRow("CSSTransformValue.is2D (translate 2D)", true, String(v2d.is2D));

        const t3d = new CSSTranslate(CSS.px(5), CSS.px(7), CSS.px(1));
        const v3d = new CSSTransformValue([t3d]);
        addRow("CSSTransformValue.is2D (translate 3D)", true, String(v3d.is2D));
      } else {
        // Fallback path: computeStyle transform matrix dimensionality heuristic
        const el = document.createElement("div");
        el.style.transform = "translate(5px,7px)";
        document.body.appendChild(el);
        const m2d = getComputedStyle(el).transform;
        el.style.transform = "translate3d(5px,7px,1px)";
        const m3d = getComputedStyle(el).transform;
        el.remove();
        addRow("CSSTransformValue.is2D (fallback 2D matrix)", true, m2d || "none");
        addRow("CSSTransformValue.is2D (fallback 3D matrix)", true, m3d || "none");
      }
    }

    // CSSPerspective.length
    if (!supports("CSSPerspective")) {
      addRow("CSSPerspective.length", false, "CSSPerspective unavailable");
    } else {
      tryCall("CSSPerspective.length", () => {
        const p = new CSSPerspective(CSS.px(500));
        return `${precision(p.length.value)} ${p.length.unit}`;
      });
    }
  }

  function vectorizeTable() {
    // Build a deterministic, API-ordered vector from the rows
    const order = [
      "CSSAnimation.animationName",
      "CSSNumericValue (global)",
      "CSSNumericValue.add",
      "CSSNumericValue.sub",
      "CSSNumericValue.mul",
      "CSSNumericValue.div",
      "CSSNumericValue.to (cm→px)",
      "CSSNumericValue.to (deg→rad)",
      "CSSNumericValue.to (rad→deg)",
      "CSSNumericValue.toSum('px')",
      "CSSNumericValue.max(px10, px4)",
      "CSSNumericValue.min(px10, px4)",
      "CSSTransformValue.is2D (translate 2D)",
      "CSSTransformValue.is2D (translate 3D)",
      "CSSTransformValue.is2D (fallback 2D matrix)",
      "CSSTransformValue.is2D (fallback 3D matrix)",
      "CSSPerspective.length"
    ];
    const rows = Array.from(tbody.querySelectorAll("tr"));
    const map = new Map(rows.map(r => {
      const cells = r.querySelectorAll("td");
      return [cells[0].textContent, { sup: cells[1].textContent, val: cells[2].textContent }];
    }));
    const vec = order.map(k => {
      const e = map.get(k);
      return e ? `${k}|${e.sup}|${e.val}` : `${k}|no|n/a`;
    });
    return vec.join("\n");
  }

  btn.onclick = async () => {
    tbody.innerHTML = "";
    fpOut.textContent = "…";

    // 1) CSSAnimation.animationName
    const animName = probeCSSAnimationName();
    const supported = (animName && animName !== "n/a");
    addRow("CSSAnimation.animationName", supported, supported ? animName : "unavailable");

    // 2) CSSNumericValue family
    probeCSSNumeric();

    // 3) CSSTransformValue.is2D and CSSPerspective.length
    probeTransforms();

    // 4) Build a stable vector from the rows and hash it
    const vector = vectorizeTable();
    const hash = await sha256Hex(vector);
    fpOut.textContent = `Vector:\n${vector}\n\nSHA-256:\n${hash}`;
  };
})();
</script>
