<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebNN Demo â€“ Extended Calculations</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 20px;
      background: #f7f7f7;
    }
    h1 {
      margin-bottom: 0.5rem;
    }
    .example {
      background: #fff;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    button {
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #ccc;
      cursor: pointer;
      margin-bottom: 8px;
    }
    pre {
      background: #111;
      color: #eee;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    .error {
      color: #b00020;
      font-weight: bold;
    }
    .note {
      font-size: 0.9rem;
      color: #555;
    }
  </style>
</head>
<body>
  <h1>WebNN Extended Result Viewer</h1>
  <p class="note">
    This page runs your WebNN examples and also does extra calculations:
    CPU-side reference results, sums, means, and element-wise differences.
  </p>

  <div class="example">
    <h2>Example 1: ((0.5 + input1) * (0.5 + input2))</h2>
    <button id="run1">Run Example 1</button>
    <div id="status1"></div>
    <pre id="output1"></pre>
  </div>

  <div class="example">
    <h2>Example 2: C = 0.2 * A + B</h2>
    <button id="run2">Run Example 2</button>
    <div id="status2"></div>
    <pre id="output2"></pre>
  </div>

  <script>
    // ---- Helper functions ----
    function arrayToString(arr) {
      return '[' + Array.from(arr).join(', ') + ']';
    }

    function computeStats(arr) {
      let sum = 0;
      for (let i = 0; i < arr.length; i++) {
        sum += arr[i];
      }
      const mean = arr.length > 0 ? sum / arr.length : 0;
      return { sum, mean };
    }

    function diffArrays(a, b) {
      const len = Math.min(a.length, b.length);
      const diff = new Float32Array(len);
      for (let i = 0; i < len; i++) {
        diff[i] = a[i] - b[i];
      }
      return diff;
    }

    function showError(containerId, msg) {
      const el = document.getElementById(containerId);
      el.innerHTML = '<span class="error">' + msg + '</span>';
    }

    // ---- Example 1 ----
    async function runExample1() {
      const statusEl = document.getElementById('status1');
      const outputEl = document.getElementById('output1');
      statusEl.textContent = 'Running example 1...';
      outputEl.textContent = '';

      try {
        if (!('ml' in navigator)) {
          showError('status1', 'navigator.ml is not supported in this browser.');
          return;
        }

        const TENSOR_SHAPE = [1, 2, 2, 2];
        const TENSOR_SIZE = 8;

        const context = await navigator.ml.createContext();
        const builder = new MLGraphBuilder(context);

        const desc = {
          dataType: 'float32',
          shape: TENSOR_SHAPE
        };

        // constant1 is a constant MLOperand with the value 0.5.
        const constantBuffer1 = new Float32Array(TENSOR_SIZE).fill(0.5);
        const constant1 = builder.constant(desc, constantBuffer1);

        // input1 is one of the input MLOperands. Its value will be set before execution.
        const input1 = builder.input('input1', desc);

        // constant2 is another constant MLOperand with the value 0.5.
        const constantBuffer2 = new Float32Array(TENSOR_SIZE).fill(0.5);
        const constant2 = builder.constant(desc, constantBuffer2);

        // input2 is another input MLOperand. Its value will be set before execution.
        const input2 = builder.input('input2', desc);

        // intermediateOutput1 is the output of the first Add operation.
        const intermediateOutput1 = builder.add(constant1, input1);

        // intermediateOutput2 is the output of the second Add operation.
        const intermediateOutput2 = builder.add(constant2, input2);

        // output is the output MLOperand of the Mul operation.
        const outputOperand = builder.mul(intermediateOutput1, intermediateOutput2);

        // Build the graph. Name the output 'output'.
        const graph = await builder.build({ output: outputOperand });

        // Create input and output tensors.
        const [inputTensor1, inputTensor2, outputTensor] = await Promise.all([
          context.createTensor({ dataType: 'float32', shape: TENSOR_SHAPE, writable: true }),
          context.createTensor({ dataType: 'float32', shape: TENSOR_SHAPE, writable: true }),
          context.createTensor({ dataType: 'float32', shape: TENSOR_SHAPE, readable: true })
        ]);

        // Initialize input values (example values).
        const inputData1 = new Float32Array(TENSOR_SIZE).fill(1.0);
        const inputData2 = new Float32Array(TENSOR_SIZE).fill(0.8);

        await Promise.all([
          context.writeTensor(inputTensor1, inputData1),
          context.writeTensor(inputTensor2, inputData2)
        ]);

        // Execute the graph.
        const inputs = {
          input1: inputTensor1,
          input2: inputTensor2
        };
        const outputs = {
          output: outputTensor
        };

        await context.dispatch(graph, inputs, outputs);

        // Read back the result from WebNN.
        const result = await context.readTensor(outputTensor);
        const webnnResult = new Float32Array(result);

        // ---- Extra calculations (CPU-side reference & stats) ----
        // CPU reference: (0.5 + input1[i]) * (0.5 + input2[i])
        const cpuResult = new Float32Array(TENSOR_SIZE);
        for (let i = 0; i < TENSOR_SIZE; i++) {
          cpuResult[i] = (0.5 + inputData1[i]) * (0.5 + inputData2[i]);
        }

        const statsWebNN = computeStats(webnnResult);
        const statsCPU   = computeStats(cpuResult);
        const diff       = diffArrays(webnnResult, cpuResult);
        const statsDiff  = computeStats(diff);

        statusEl.textContent = 'Done.';

        outputEl.textContent =
          'Tensor shape: ' + JSON.stringify(TENSOR_SHAPE) + '\n\n' +
          'Input1:            ' + arrayToString(inputData1) + '\n' +
          'Input2:            ' + arrayToString(inputData2) + '\n\n' +
          'Formula: (0.5 + input1) * (0.5 + input2)\n\n' +
          'WebNN result:      ' + arrayToString(webnnResult) + '\n' +
          '  sum  = ' + statsWebNN.sum.toFixed(6) + '\n' +
          '  mean = ' + statsWebNN.mean.toFixed(6) + '\n\n' +
          'CPU reference:     ' + arrayToString(cpuResult) + '\n' +
          '  sum  = ' + statsCPU.sum.toFixed(6) + '\n' +
          '  mean = ' + statsCPU.mean.toFixed(6) + '\n\n' +
          'Difference (WebNN - CPU):\n' +
          '  values: ' + arrayToString(diff) + '\n' +
          '  sum of diff  = ' + statsDiff.sum.toFixed(6) + '\n' +
          '  mean of diff = ' + statsDiff.mean.toFixed(6);
      } catch (err) {
        console.error(err);
        showError('status1', 'Error during Example 1: ' + err);
      }
    }

    // ---- Example 2 ----
    async function runExample2() {
      const statusEl = document.getElementById('status2');
      const outputEl = document.getElementById('output2');
      statusEl.textContent = 'Running example 2...';
      outputEl.textContent = '';

      try {
        if (!('ml' in navigator)) {
          showError('status2', 'navigator.ml is not supported in this browser.');
          return;
        }

        const descriptor = {
          dataType: 'float32',
          shape: [2, 2]
        };

        const context = await navigator.ml.createContext();
        const builder = new MLGraphBuilder(context);

        // 1. Create a computational graph 'C = 0.2 * A + B'.
        const constant = builder.constant(descriptor, new Float32Array(4).fill(0.2));
        const A = builder.input('A', descriptor);
        const B = builder.input('B', descriptor);
        const C = builder.add(builder.mul(A, constant), B);

        // 2. Compile the graph.
        const graph = await builder.build({ 'C': C });

        // 3. Create reusable input and output tensors.
        const [inputTensorA, inputTensorB, outputTensorC] = await Promise.all([
          context.createTensor({ dataType: A.dataType, shape: A.shape, writable: true }),
          context.createTensor({ dataType: B.dataType, shape: B.shape, writable: true }),
          context.createTensor({ dataType: C.dataType, shape: C.shape, readable: true })
        ]);

        // 4. Initialize the inputs.
        const dataA = new Float32Array(4).fill(1.0);
        const dataB = new Float32Array(4).fill(0.8);

        await Promise.all([
          context.writeTensor(inputTensorA, dataA),
          context.writeTensor(inputTensorB, dataB)
        ]);

        // 5. Execute the graph.
        const inputs = {
          'A': inputTensorA,
          'B': inputTensorB
        };
        const outputs = {
          'C': outputTensorC
        };
        await context.dispatch(graph, inputs, outputs);

        // 6. Read back the computed result.
        const result = await context.readTensor(outputTensorC);
        const webnnResult = new Float32Array(result);

        // ---- Extra calculations (CPU-side reference & stats) ----
        // CPU reference: C = 0.2 * A + B
        const cpuResult = new Float32Array(4);
        for (let i = 0; i < 4; i++) {
          cpuResult[i] = 0.2 * dataA[i] + dataB[i];
        }

        const statsWebNN = computeStats(webnnResult);
        const statsCPU   = computeStats(cpuResult);
        const diff       = diffArrays(webnnResult, cpuResult);
        const statsDiff  = computeStats(diff);

        statusEl.textContent = 'Done.';

        outputEl.textContent =
          'Shape: ' + JSON.stringify(descriptor.shape) + '\n\n' +
          'A:      ' + arrayToString(dataA) + '\n' +
          'B:      ' + arrayToString(dataB) + '\n\n' +
          'Formula: C = 0.2 * A + B\n\n' +
          'WebNN result (C):  ' + arrayToString(webnnResult) + '\n' +
          '  sum  = ' + statsWebNN.sum.toFixed(6) + '\n' +
          '  mean = ' + statsWebNN.mean.toFixed(6) + '\n\n' +
          'CPU reference (C): ' + arrayToString(cpuResult) + '\n' +
          '  sum  = ' + statsCPU.sum.toFixed(6) + '\n' +
          '  mean = ' + statsCPU.mean.toFixed(6) + '\n\n' +
          'Difference (WebNN - CPU):\n' +
          '  values: ' + arrayToString(diff) + '\n' +
          '  sum of diff  = ' + statsDiff.sum.toFixed(6) + '\n' +
          '  mean of diff = ' + statsDiff.mean.toFixed(6);
      } catch (err) {
        console.error(err);
        showError('status2', 'Error during Example 2: ' + err);
      }
    }

    // Hook up buttons once the DOM is ready.
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('run1').addEventListener('click', runExample1);
      document.getElementById('run2').addEventListener('click', runExample2);

      if (!('ml' in navigator)) {
        showError('status1', 'navigator.ml is not available. Enable WebNN or use a compatible browser.');
        showError('status2', 'navigator.ml is not available. Enable WebNN or use a compatible browser.');
      }
    });
  </script>
</body>
</html>
