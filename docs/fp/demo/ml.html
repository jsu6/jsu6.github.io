<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>WebNN All Examples - Minimal UI</title>
</head>
<body>

<h2>WebNN Test Examples (Minimal UI, Advanced)</h2>

<button onclick="runExample1()">Run Example 1</button>
<pre id="out1"></pre>

<button onclick="runExample2()">Run Example 2</button>
<pre id="out2"></pre>

<button onclick="runExample3()">Run Example 3 (MatMul)</button>
<pre id="out3"></pre>

<button onclick="runExample4()">Run Example 4 (Sin + Cos)</button>
<pre id="out4"></pre>

<button onclick="runExample5()">Run Example 5 (Broadcast + ReLU)</button>
<pre id="out5"></pre>

<button onclick="runExample6()">Run Example 6 (Mini MLP)</button>
<pre id="out6"></pre>

<hr>

<h3>Advanced Calculations</h3>

<button onclick="example7_multiBranch()">Run Example 7 (Multi-Branch Chain)</button>
<pre id="out7"></pre>

<button onclick="example8_layerNorm()">Run Example 8 (LayerNorm)</button>
<pre id="out8"></pre>

<button onclick="example9_conv1d()">Run Example 9 (Simulated Conv1D)</button>
<pre id="out9"></pre>

<button onclick="example10_pipeline()">Run Example 10 (Full MLP+GELU+Norm)</button>
<pre id="out10"></pre>

<hr>

<h3>Extra: Conv2D, Softmax, Attention, GRU, Residual, Transformer</h3>

<button onclick="runExample11_conv2d()">Run Example 11 (Conv2D)</button>
<pre id="out11"></pre>

<button onclick="runExample12_softmax()">Run Example 12 (Softmax / LogSoftmax)</button>
<pre id="out12"></pre>

<button onclick="runExample13_attention()">Run Example 13 (Self-Attention)</button>
<pre id="out13"></pre>

<button onclick="runExample14_gru()">Run Example 14 (GRU-style Cell)</button>
<pre id="out14"></pre>

<button onclick="runExample15_residual()">Run Example 15 (Residual + LayerNorm)</button>
<pre id="out15"></pre>

<button onclick="runExample16_transformer()">Run Example 16 (Tiny Transformer Encoder)</button>
<pre id="out16"></pre>

<script>
// =======================================================
// Helper
// =======================================================
function arr(a) { return '[' + Array.from(a).join(', ') + ']'; }

// =======================================================
// Example 1
// =======================================================
async function runExample1() {
  const out = document.getElementById("out1");
  out.textContent = "Running Example 1...";

  const TENSOR_SHAPE = [1,2,2,2];
  const TENSOR_SIZE = 8;

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const desc = { dataType:"float32", shape:TENSOR_SHAPE };

  const c1 = b.constant(desc, new Float32Array(TENSOR_SIZE).fill(0.5));
  const c2 = b.constant(desc, new Float32Array(TENSOR_SIZE).fill(0.5));
  const in1 = b.input("in1", desc);
  const in2 = b.input("in2", desc);

  const Y = b.mul(b.add(c1,in1), b.add(c2,in2));
  const graph = await b.build({Y});

  const t1 = await ctx.createTensor({...desc, writable:true});
  const t2 = await ctx.createTensor({...desc, writable:true});
  const tY = await ctx.createTensor({...desc, readable:true});

  const d1 = new Float32Array(TENSOR_SIZE).fill(1.0);
  const d2 = new Float32Array(TENSOR_SIZE).fill(0.8);

  await ctx.writeTensor(t1, d1);
  await ctx.writeTensor(t2, d2);
  await ctx.dispatch(graph, {in1:t1, in2:t2}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 2
// =======================================================
async function runExample2() {
  const out = document.getElementById("out2");
  out.textContent = "Running Example 2...";

  const desc = { dataType:"float32", shape:[2,2] };
  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const A = b.input("A", desc);
  const B = b.input("B", desc);
  const C = b.add(b.mul(A, b.constant(desc,new Float32Array(4).fill(0.2))), B);

  const graph = await b.build({C});
  const tA = await ctx.createTensor({...desc, writable:true});
  const tB = await ctx.createTensor({...desc, writable:true});
  const tC = await ctx.createTensor({...desc, readable:true});

  const dA = new Float32Array(4).fill(1.0);
  const dB = new Float32Array(4).fill(0.8);

  await ctx.writeTensor(tA, dA);
  await ctx.writeTensor(tB, dB);
  await ctx.dispatch(graph, {A:tA,B:tB}, {C:tC});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tC)));
}

// =======================================================
// Example 3 (MatMul)
// =======================================================
async function runExample3() {
  const out = document.getElementById("out3");
  out.textContent = "Running Example 3...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const A = b.input("A", {dataType:"float32", shape:[2,3]});
  const B = b.input("B", {dataType:"float32", shape:[3,2]});
  const M = b.matmul(A,B);

  const graph = await b.build({M});

  const tA = await ctx.createTensor({dataType:"float32", shape:[2,3], writable:true});
  const tB = await ctx.createTensor({dataType:"float32", shape:[3,2], writable:true});
  const tM = await ctx.createTensor({dataType:"float32", shape:[2,2], readable:true});

  const dA = new Float32Array([1,2,3,4,5,6]);
  const dB = new Float32Array([7,8,9,10,11,12]);

  await ctx.writeTensor(tA, dA);
  await ctx.writeTensor(tB, dB);
  await ctx.dispatch(graph, {A:tA,B:tB}, {M:tM});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tM)));
}

// =======================================================
// Example 4 (Sin + Cos)
// =======================================================
async function runExample4() {
  const out = document.getElementById("out4");
  out.textContent = "Running Example 4...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const X = b.input("X", {dataType:"float32", shape:[4]});
  const Y = b.add(b.sin(X), b.cos(X));

  const graph = await b.build({Y});
  const tX = await ctx.createTensor({dataType:"float32", shape:[4], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[4], readable:true});

  const dX = new Float32Array([0,Math.PI/2,Math.PI,3*Math.PI/2]);
  await ctx.writeTensor(tX, dX);

  await ctx.dispatch(graph, {X:tX}, {Y:tY});
  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 5 (Broadcast + ReLU)
// =======================================================
async function runExample5() {
  const out = document.getElementById("out5");
  out.textContent = "Running Example 5...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const desc = {dataType:"float32", shape:[1,2,2,3]};
  const X = b.input("X", desc);

  const scale = b.constant({dataType:"float32", shape:[1,1,1,3]},
                           new Float32Array([1,0.5,2]));
  const bias  = b.constant({dataType:"float32", shape:[1,1,1,3]},
                           new Float32Array([0.1,-0.2,0.3]));

  const Y = b.relu(b.add(b.mul(X,scale), bias));
  const graph = await b.build({Y});

  const tX = await ctx.createTensor({...desc, writable:true});
  const tY = await ctx.createTensor({...desc, readable:true});

  const dX = new Float32Array([
    1,2,3,
    4,5,6,
    1,1,1,
    0,0.5,2
  ]);

  await ctx.writeTensor(tX, dX);
  await ctx.dispatch(graph, {X:tX}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 6 (Mini MLP)
// =======================================================
async function runExample6() {
  const out = document.getElementById("out6");
  out.textContent = "Running Example 6...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const X = b.input("X", {dataType:"float32", shape:[1,4]});

  function dense(input, inF, outF) {
    const W = b.constant({dataType:"float32", shape:[inF,outF]},
                         new Float32Array(inF*outF).fill(0.1));
    const B = b.constant({dataType:"float32", shape:[1,outF]},
                         new Float32Array(outF).fill(0.01));
    return b.relu(b.add(b.matmul(input,W),B));
  }

  const L1 = dense(X,4,6);
  const L2 = dense(L1,6,6);
  const L3 = dense(L2,6,4);
  const Y  = dense(L3,4,2);

  const graph = await b.build({Y});
  const tX = await ctx.createTensor({dataType:"float32", shape:[1,4], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[1,2], readable:true});

  await ctx.writeTensor(tX, new Float32Array([1,2,3,4]));
  await ctx.dispatch(graph, {X:tX}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 7 — Multi-Branch Computational Chain
// =======================================================
async function example7_multiBranch() {
  const out = document.getElementById("out7");
  out.textContent = "Running Example 7...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const A = b.input("A", {dataType:"float32", shape:[1,4]});

  const W1 = b.constant({dataType:"float32", shape:[4,4]},
                        new Float32Array(16).fill(0.3));
  const W2 = b.constant({dataType:"float32", shape:[4,4]},
                        new Float32Array(16).fill(0.1));

  const B1 = b.constant({dataType:"float32", shape:[1,4]},
                        new Float32Array([0.1,0.2,0.3,0.4]));
  const B2 = b.constant({dataType:"float32", shape:[1,4]},
                        new Float32Array([0.05,0.1,0.15,0.2]));

  const branch1 = b.add(b.matmul(A,W1), B1);
  const branch2 = b.sin(b.add(b.matmul(A,W2), B2));

  const Y = b.relu(b.add(branch1, branch2));
  const graph = await b.build({Y});

  const tA = await ctx.createTensor({dataType:"float32", shape:[1,4], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[1,4], readable:true});

  await ctx.writeTensor(tA, new Float32Array([1,2,3,4]));
  await ctx.dispatch(graph, {A:tA}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 8 — LayerNorm Chain
// =======================================================
async function example8_layerNorm() {
  const out = document.getElementById("out8");
  out.textContent = "Running Example 8...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const X = b.input("X", {dataType:"float32", shape:[1,8]});
  const eps = 1e-5;

  const mean = b.div(
    b.reduceSum(X, {axes:[1], keepDimensions:true}),
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([8]))
  );

  const diff = b.sub(X, mean);
  const sq = b.mul(diff,diff);

  const variance = b.div(
    b.reduceSum(sq, {axes:[1], keepDimensions:true}),
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([8]))
  );

  const denom = b.sqrt(b.add(variance,
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([eps]))
  ));

  const Y = b.div(diff, denom);

  const graph = await b.build({Y});

  const tX = await ctx.createTensor({dataType:"float32", shape:[1,8], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[1,8], readable:true});

  await ctx.writeTensor(tX, new Float32Array([1,2,3,4,5,6,7,8]));
  await ctx.dispatch(graph, {X:tX}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 9 — Simulated Conv1D
// =======================================================
async function example9_conv1d() {
  const out = document.getElementById("out9");
  out.textContent = "Running Example 9...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const X = b.input("X", {dataType:"float32", shape:[1,6]});
  const W = b.constant({dataType:"float32", shape:[1,3]},
                       new Float32Array([0.2,0.5,0.3]));

  const outputs = [];
  for (let i=0; i<4; i++) {
    const slice = b.slice(X, [0,i],[1,i+3]);
    const mul = b.mul(slice, W);
    outputs.push(b.reduceSum(mul, {axes:[1], keepDimensions:false}));
  }

  const Y = b.concat(outputs, 1);
  const graph = await b.build({Y});

  const tX = await ctx.createTensor({dataType:"float32", shape:[1,6], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[1,4], readable:true});

  await ctx.writeTensor(tX, new Float32Array([1,2,3,4,5,6]));
  await ctx.dispatch(graph, {X:tX}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 10 — Full Pipeline (GELU + LayerNorm)
// =======================================================
async function example10_pipeline() {
  const out = document.getElementById("out10");
  out.textContent = "Running Example 10...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const A = b.input("A", {dataType:"float32", shape:[1,4]});

  const W = b.constant({dataType:"float32", shape:[4,4]},
                       new Float32Array(16).fill(0.2));

  const H = b.matmul(A, W);

  const c044 = b.constant({dataType:"float32", shape:[1,4]},
                          new Float32Array([0.044715,0.044715,0.044715,0.044715]));
  const sqrt2pi = Math.sqrt(2/Math.PI);

  const X3 = b.mul(b.mul(H,H),H);
  const inner = b.add(H, b.mul(c044,X3));

  const scaled = b.mul(
    b.constant({dataType:"float32", shape:[1,4]},
               new Float32Array([sqrt2pi,sqrt2pi,sqrt2pi,sqrt2pi])),
    inner
  );

  const tanhVal = b.tanh(scaled);

  const gelu = b.mul(
    b.mul(H, b.constant({dataType:"float32",shape:[1,4]},new Float32Array([0.5,0.5,0.5,0.5]))),
    b.add(b.constant({dataType:"float32",shape:[1,4]},new Float32Array([1,1,1,1])), tanhVal)
  );

  const mean = b.div(
    b.reduceSum(gelu, {axes:[1], keepDimensions:true}),
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([4]))
  );
  const diff = b.sub(gelu,mean);
  const varVal = b.div(
    b.reduceSum(b.mul(diff,diff), {axes:[1], keepDimensions:true}),
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([4]))
  );

  const denom = b.sqrt(b.add(varVal,
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([1e-5]))
  ));

  const norm = b.div(diff, denom);

  const scale = b.constant({dataType:"float32", shape:[1,4]},
                           new Float32Array([1.2,1.0,0.8,1.5]));
  const bias  = b.constant({dataType:"float32", shape:[1,4]},
                           new Float32Array([0.1,-0.1,0.05,0.2]));

  const Y = b.add(b.mul(norm,scale), bias);

  const graph = await b.build({Y});

  const tA = await ctx.createTensor({dataType:"float32", shape:[1,4], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[1,4], readable:true});

  await ctx.writeTensor(tA, new Float32Array([1,2,3,4]));
  await ctx.dispatch(graph, {A:tA}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 11 — Conv2D (using conv2d op, NHWC)
// =======================================================
async function runExample11_conv2d() {
  const out = document.getElementById("out11");
  out.textContent = "Running Example 11 (Conv2D)...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  // Input: [N,H,W,C] = [1,4,4,1]
  const X = b.input("X", {dataType:"float32", shape:[1,4,4,1]});

  // Filter: [outC, filterH, filterW, inC] = [1,3,3,1]
  const W = b.constant(
    {dataType:"float32", shape:[1,3,3,1]},
    new Float32Array([
      0, 1, 0,
      1,-4, 1,
      0, 1, 0
    ])
  );

  const Y = b.conv2d(X, W, {
    inputLayout: 'nhwc',
    filterLayout: 'ohwi',
    strides: [1,1],
    padding: [0,0,0,0],
    dilations: [1,1],
    groups: 1
  });

  const graph = await b.build({Y});

  const tX = await ctx.createTensor({dataType:"float32", shape:[1,4,4,1], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[1,2,2,1], readable:true});

  // Simple 4x4 ramp image
  const img = new Float32Array([
    1,2,3,4,
    5,6,7,8,
    9,10,11,12,
    13,14,15,16
  ]);
  // NHWC: expand channel dim
  const dataX = new Float32Array(1*4*4*1);
  for (let i = 0; i < img.length; i++) dataX[i] = img[i];

  await ctx.writeTensor(tX, dataX);
  await ctx.dispatch(graph, {X:tX}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 12 — Softmax / LogSoftmax
// =======================================================
async function runExample12_softmax() {
  const out = document.getElementById("out12");
  out.textContent = "Running Example 12 (Softmax)...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const X = b.input("X", {dataType:"float32", shape:[1,4]});

  const soft = b.softmax(X, {axis:1});
  const logSoft = b.logSoftmax(X, {axis:1});

  const graph = await b.build({soft, logSoft});

  const tX = await ctx.createTensor({dataType:"float32", shape:[1,4], writable:true});
  const tSoft = await ctx.createTensor({dataType:"float32", shape:[1,4], readable:true});
  const tLogSoft = await ctx.createTensor({dataType:"float32", shape:[1,4], readable:true});

  await ctx.writeTensor(tX, new Float32Array([1,2,3,4]));
  await ctx.dispatch(graph, {X:tX}, {soft:tSoft, logSoft:tLogSoft});

  const s = new Float32Array(await ctx.readTensor(tSoft));
  const ls = new Float32Array(await ctx.readTensor(tLogSoft));

  out.textContent = "Softmax: " + arr(s) + "\nLogSoftmax: " + arr(ls);
}

// =======================================================
// Example 13 — Self-Attention (single head)
// =======================================================
async function runExample13_attention() {
  const out = document.getElementById("out13");
  out.textContent = "Running Example 13 (Self-Attention)...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  // Sequence length = 2, model dim = 4
  const X = b.input("X", {dataType:"float32", shape:[2,4]});

  function makeWeight() {
    return b.constant(
      {dataType:"float32", shape:[4,4]},
      new Float32Array(16).fill(0.1)
    );
  }

  const Wq = makeWeight();
  const Wk = makeWeight();
  const Wv = makeWeight();

  const Q = b.matmul(X, Wq); // [2,4]
  const K = b.matmul(X, Wk); // [2,4]
  const V = b.matmul(X, Wv); // [2,4]

  // K^T: [4,2]
  const Kt = b.transpose(K, {permutation:[1,0]});

  // scores: [2,2]
  const scoresRaw = b.matmul(Q, Kt);

  const scale = 1 / Math.sqrt(4);
  const scores = b.mul(
    scoresRaw,
    b.constant({dataType:"float32", shape:[2,2]}, new Float32Array(4).fill(scale))
  );

  const attn = b.softmax(scores, {axis:1}); // [2,2]

  const outVec = b.matmul(attn, V); // [2,4]

  const graph = await b.build({outVec});

  const tX = await ctx.createTensor({dataType:"float32", shape:[2,4], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[2,4], readable:true});

  await ctx.writeTensor(tX, new Float32Array([
    1,0,0,0,
    0,1,0,0
  ]));

  await ctx.dispatch(graph, {X:tX}, {outVec:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 14 — GRU-style Cell (one step)
// =======================================================
async function runExample14_gru() {
  const out = document.getElementById("out14");
  out.textContent = "Running Example 14 (GRU-style cell)...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  // x_t, h_prev: [1,3]
  const X = b.input("X", {dataType:"float32", shape:[1,3]});
  const Hprev = b.input("Hprev", {dataType:"float32", shape:[1,3]});

  function w(name) {
    return b.constant({dataType:"float32", shape:[3,3]}, new Float32Array(9).fill(0.1));
  }
  function b3(val) {
    return b.constant({dataType:"float32", shape:[1,3]}, new Float32Array([val,val,val]));
  }

  const Wz = w("Wz"), Uz = w("Uz"), bz = b3(0.1);
  const Wr = w("Wr"), Ur = w("Ur"), br = b3(0.1);
  const Wh = w("Wh"), Uh = w("Uh"), bh = b3(0.0);

  const z = b.sigmoid(
    b.add(
      b.add(b.matmul(X,Wz), b.matmul(Hprev,Uz)),
      bz
    )
  );

  const r = b.sigmoid(
    b.add(
      b.add(b.matmul(X,Wr), b.matmul(Hprev,Ur)),
      br
    )
  );

  const rH = b.mul(r, Hprev);

  const hTilde = b.tanh(
    b.add(
      b.add(b.matmul(X,Wh), b.matmul(rH,Uh)),
      bh
    )
  );

  const oneMinusZ = b.sub(
    b.constant({dataType:"float32", shape:[1,3]}, new Float32Array([1,1,1])),
    z
  );

  const Hnew = b.add(
    b.mul(oneMinusZ, Hprev),
    b.mul(z, hTilde)
  );

  const graph = await b.build({Hnew});

  const tX = await ctx.createTensor({dataType:"float32", shape:[1,3], writable:true});
  const tHprev = await ctx.createTensor({dataType:"float32", shape:[1,3], writable:true});
  const tHnew = await ctx.createTensor({dataType:"float32", shape:[1,3], readable:true});

  await ctx.writeTensor(tX, new Float32Array([1,0,0]));
  await ctx.writeTensor(tHprev, new Float32Array([0,0.5,0]));

  await ctx.dispatch(graph, {X:tX, Hprev:tHprev}, {Hnew:tHnew});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tHnew)));
}

// =======================================================
// Example 15 — Residual Block + LayerNorm
// =======================================================
async function runExample15_residual() {
  const out = document.getElementById("out15");
  out.textContent = "Running Example 15 (Residual + LayerNorm)...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  const X = b.input("X", {dataType:"float32", shape:[1,4]});

  const W = b.constant({dataType:"float32", shape:[4,4]},
                       new Float32Array(16).fill(0.25));
  const B = b.constant({dataType:"float32", shape:[1,4]},
                       new Float32Array([0.1,0.2,-0.1,0.05]));

  const H = b.add(b.matmul(X,W), B);

  const eps = 1e-5;

  const mean = b.div(
    b.reduceSum(H, {axes:[1], keepDimensions:true}),
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([4]))
  );
  const diff = b.sub(H,mean);
  const varVal = b.div(
    b.reduceSum(b.mul(diff,diff), {axes:[1], keepDimensions:true}),
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([4]))
  );
  const denom = b.sqrt(b.add(varVal,
    b.constant({dataType:"float32", shape:[1,1]}, new Float32Array([eps]))
  ));
  const norm = b.div(diff, denom);

  const Y = b.add(b.relu(norm), X);

  const graph = await b.build({Y});

  const tX = await ctx.createTensor({dataType:"float32", shape:[1,4], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[1,4], readable:true});

  await ctx.writeTensor(tX, new Float32Array([1,2,3,4]));
  await ctx.dispatch(graph, {X:tX}, {Y:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}

// =======================================================
// Example 16 — Tiny Transformer Encoder (single head)
// =======================================================
async function runExample16_transformer() {
  const out = document.getElementById("out16");
  out.textContent = "Running Example 16 (Tiny Transformer Encoder)...";

  const ctx = await navigator.ml.createContext();
  const b = new MLGraphBuilder(ctx);

  // Sequence length = 2, d_model = 4
  const X = b.input("X", {dataType:"float32", shape:[2,4]});

  // ---- LayerNorm helper for [2,4] along last dim ----
  function layerNorm(input) {
    const eps = 1e-5;
    const mean = b.div(
      b.reduceSum(input, {axes:[1], keepDimensions:true}),
      b.constant({dataType:"float32", shape:[2,1]}, new Float32Array([4,4]))
    );
    const diff = b.sub(input, mean);
    const varVal = b.div(
      b.reduceSum(b.mul(diff,diff), {axes:[1], keepDimensions:true}),
      b.constant({dataType:"float32", shape:[2,1]}, new Float32Array([4,4]))
    );
    const denom = b.sqrt(b.add(
      varVal,
      b.constant({dataType:"float32", shape:[2,1]}, new Float32Array([eps,eps]))
    ));
    return b.div(diff, denom);
  }

  function weight44() {
    return b.constant({dataType:"float32", shape:[4,4]},
      new Float32Array(16).fill(0.15)
    );
  }

  // ---- Self-Attention ----
  const Wq = weight44();
  const Wk = weight44();
  const Wv = weight44();

  const Q = b.matmul(X, Wq);
  const K = b.matmul(X, Wk);
  const V = b.matmul(X, Wv);

  const Kt = b.transpose(K, {permutation:[1,0]});
  const scoresRaw = b.matmul(Q, Kt); // [2,2]

  const scale = 1 / Math.sqrt(4);
  const scores = b.mul(
    scoresRaw,
    b.constant({dataType:"float32", shape:[2,2]}, new Float32Array(4).fill(scale))
  );

  const attn = b.softmax(scores, {axis:1}); // [2,2]
  const attnOut = b.matmul(attn, V); // [2,4]

  const residual1 = b.add(X, attnOut);
  const ln1 = layerNorm(residual1);

  // ---- FeedForward: 4→4 (twice) ----
  const W1 = weight44();
  const B1 = b.constant({dataType:"float32", shape:[1,4]},
    new Float32Array([0.1,0.0,-0.1,0.05])
  );

  const hidden = b.relu(b.add(b.matmul(ln1, W1), B1));

  const W2 = weight44();
  const B2 = b.constant({dataType:"float32", shape:[1,4]},
    new Float32Array([-0.05,0.02,0.03,0.0])
  );

  const ffOut = b.add(b.matmul(hidden, W2), B2);

  const residual2 = b.add(residual1, ffOut);
  const ln2 = layerNorm(residual2);

  const graph = await b.build({ln2});

  const tX = await ctx.createTensor({dataType:"float32", shape:[2,4], writable:true});
  const tY = await ctx.createTensor({dataType:"float32", shape:[2,4], readable:true});

  await ctx.writeTensor(tX, new Float32Array([
    1,0,0,0,
    0,1,0,0
  ]));

  await ctx.dispatch(graph, {X:tX}, {ln2:tY});

  out.textContent = arr(new Float32Array(await ctx.readTensor(tY)));
}
</script>

</body>
</html>
