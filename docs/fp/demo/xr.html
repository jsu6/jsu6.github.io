<!doctype html>
<meta charset="utf-8">
<title>WebXR Fingerprinting PoC — Chrome-friendly</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 20px; }
  button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; cursor: pointer; }
  #status { margin: 10px 0 14px; }
  pre { background:#0b0b0b; color:#d7eaff; padding:12px; border-radius:10px; overflow:auto; }
  table { border-collapse: collapse; width: 100%; margin-top: 12px; }
  th, td { border: 1px solid #ddd; padding: 6px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; }
  th { background: #f6f8fa; text-align: left; }
  .ok { color: #0a8a0a; font-weight: 600; }
  .no { color: #b00020; font-weight: 600; }
  .warn { color: #b37400; font-weight: 600; }
</style>

<h1>WebXR Fingerprinting PoC</h1>
<p>Runs a one-frame <b>inline</b> XR session, probes WebXR objects/methods, and prints a hash + detailed signals. Ends immediately—no hanging.</p>
<button id="run">Start</button>
<div id="status"></div>

<h3>Summary</h3>
<div id="summary">—</div>

<table id="results">
  <thead>
  <tr><th>API</th><th>Supported?</th><th>Value / shape / notes</th></tr>
  </thead>
  <tbody></tbody>
</table>

<h3>Raw JSON</h3>
<pre id="raw">[not collected yet]</pre>

<h3>Fingerprint hash (djb2 over JSON)</h3>
<pre id="hash">—</pre>

<script>
const $ = s => document.querySelector(s);
const tbody = $('#results tbody');
const statusEl = $('#status');
const rawEl = $('#raw');
const hashEl = $('#hash');
const summaryEl = $('#summary');
const runBtn = $('#run');

function row(name, supported, value) {
  const tr = document.createElement('tr');
  const tdA = document.createElement('td'); tdA.textContent = name;
  const tdB = document.createElement('td'); tdB.textContent = supported ? 'yes' : 'no';
  tdB.className = supported ? 'ok' : 'no';
  const tdC = document.createElement('td'); tdC.textContent = value;
  tr.append(tdA, tdB, tdC); tbody.appendChild(tr);
}

function djb2(str) {
  let h = 5381 >>> 0;
  for (let i = 0; i < str.length; i++) h = ((h << 5) + h + str.charCodeAt(i)) >>> 0;
  return ('00000000' + h.toString(16)).slice(-8);
}

function setStatus(msg, kind='') { statusEl.textContent = msg; statusEl.className = kind; }

function num(v) { return typeof v === 'number' && isFinite(v) ? Number(v.toFixed(6)) : v; }
function vec3(v) { return v ? [num(v.x), num(v.y), num(v.z)] : null; }
function quat(v) { return v ? [num(v.x), num(v.y), num(v.z), num(v.w)] : null; }

function protoHas(ctor, prop) {
  try { return !!(ctor && ctor.prototype && prop in ctor.prototype); } catch { return false; }
}

function safeCall(desc, fn) {
  try { return { ok: true, value: fn() }; }
  catch(e) { return { ok: false, error: String(e?.message || e) }; }
}

async function start() {
  runBtn.disabled = true;
  tbody.innerHTML = '';
  rawEl.textContent = '[collecting…]';
  hashEl.textContent = '—';
  summaryEl.textContent = '—';
  setStatus('', '');

  const fp = Object.create(null);

  // ===== 0) Static feature surface (exists/shape/version-ish) =====
  const staticChecks = [
    ['XRRay.direction', () => 'XRRay' in window && 'direction' in XRRay.prototype],
    ['XRRay.origin', () => 'XRRay' in window && 'origin' in XRRay.prototype],
    ['XRRay.matrix', () => 'XRRay' in window && 'matrix' in XRRay.prototype],
    ['XRRigidTransform.position', () => 'XRRigidTransform' in window && 'position' in XRRigidTransform.prototype],
    ['XRRigidTransform.orientation', () => 'XRRigidTransform' in window && 'orientation' in XRRigidTransform.prototype],
    ['XRRigidTransform.inverse', () => 'XRRigidTransform' in window && 'inverse' in XRRigidTransform.prototype],
    ['XRSession.updateRenderState', () => 'XRSession' in window && protoHas(XRSession, 'updateRenderState')],
    ['XRWebGLLayer.getViewport', () => 'XRWebGLLayer' in window && protoHas(XRWebGLLayer, 'getViewport')],
    ['XRView.eye', () => 'XRView' in window && 'eye' in XRView.prototype],
    ['XRView.refSpaceFromView', () => 'XRView' in window && 'refSpaceFromView' in XRView.prototype], // incubations
    ['XRViewerPose.views', () => 'XRViewerPose' in window && 'views' in XRViewerPose.prototype],
    ['XRGPUBinding.getViewSubImage', () => 'XRGPUBinding' in window && protoHas(XRGPUBinding, 'getViewSubImage')],
    // Incubations (Chrome behind flags/devices):
    ['XRHand.size', () => 'XRHand' in window && 'size' in XRHand.prototype],
    ['XRJointSpace.jointName', () => 'XRJointSpace' in window && 'jointName' in XRJointSpace.prototype],
  ];
  for (const [name, test] of staticChecks) {
    const supported = !!safeCall(name, test).value;
    fp[name] = supported;
    row(name, supported, supported ? 'present' : 'absent');
  }

  // Non-session objects we can instantiate right now (works on Chrome):
  if ('XRRay' in window) {
    const res = safeCall('XRRay()', () => new XRRay());
    if (res.ok) {
      fp['XRRay.origin'] = vec3(res.value.origin);
      fp['XRRay.direction'] = vec3(res.value.direction);
      fp['XRRay.matrix'] = Array.from(res.value.matrix || []);
      row('XRRay (origin/direction/matrix)', true,
        `o=${fp['XRRay.origin']} d=${fp['XRRay.direction']} m=[${fp['XRRay.matrix'].length}]`);
    } else {
      row('XRRay (constructor)', false, res.error);
    }
  }
  if ('XRRigidTransform' in window) {
    const res = safeCall('XRRigidTransform()', () => new XRRigidTransform());
    if (res.ok) {
      fp['XRRigidTransform.position'] = vec3(res.value.position);
      fp['XRRigidTransform.orientation'] = quat(res.value.orientation);
      fp['XRRigidTransform.inverse'] = !!res.value.inverse;
      row('XRRigidTransform.*', true,
        `pos=${fp['XRRigidTransform.position']} ori=${fp['XRRigidTransform.orientation']} inv=${fp['XRRigidTransform.inverse']}`);
    } else {
      row('XRRigidTransform', false, res.error);
    }
  }

  // ===== 1) Try to start an inline session (Chrome supports this) =====
  if (!('xr' in navigator)) {
    setStatus('navigator.xr is unavailable in this browser', 'no');
    row('navigator.xr', false, 'absent');
    return finish(fp);
  }
  row('navigator.xr', true, 'present');

  const inlineSupported = await navigator.xr.isSessionSupported?.('inline').catch(()=>false);
  row('isSessionSupported("inline")', !!inlineSupported, String(!!inlineSupported));

  if (!inlineSupported) {
    setStatus('Inline XR session not supported. Reporting static signals only.', 'warn');
    return finish(fp);
  }

  // WebGL context for XRWebGLLayer (Chrome creates it fine on most devices)
  const canvas = document.createElement('canvas');
  const gl = canvas.getContext('webgl', { alpha: false, antialias: false });
  row('WebGLRenderingContext', !!gl, gl ? 'ok' : 'failed');

  let session;
  try {
    session = await navigator.xr.requestSession('inline', {
      // Ask for many incubating features; Chrome will ignore unsupported ones.
      optionalFeatures: [
        'viewer','local','local-floor','bounded-floor',
        'anchors','hit-test','hand-tracking','plane-detection',
        'light-estimation','depth-sensing'
      ]
    });
    row('requestSession("inline")', true, 'started');
  } catch (e) {
    row('requestSession("inline")', false, String(e));
    setStatus('Could not start inline XR session: ' + e, 'no');
    return finish(fp);
  }

  // Attach XRWebGLLayer (fingerprintable viewport + renderState behavior)
  if (window.XRWebGLLayer && gl) {
    try {
      const layer = new XRWebGLLayer(session, gl);
      session.updateRenderState({ baseLayer: layer });
      fp['XRSession.updateRenderState'] = true;
      row('XRSession.updateRenderState', true, 'baseLayer attached');
    } catch (e) {
      row('XRSession.updateRenderState', true, 'call failed: ' + e);
    }
  } else {
    row('XRSession.updateRenderState', false, 'XRWebGLLayer or WebGL missing');
  }

  // Reference spaces
  let refSpace = null;
  for (const kind of ['local','viewer','local-floor','bounded-floor']) {
    try {
      const rs = await session.requestReferenceSpace(kind);
      if (!refSpace) refSpace = rs;
      row(`requestReferenceSpace("${kind}")`, true, 'ok');
    } catch (e) {
      row(`requestReferenceSpace("${kind}")`, false, String(e));
    }
  }
  if (!refSpace) {
    setStatus('No usable reference space; collecting minimal signals.', 'warn');
  }

  // ===== 2) One-frame probe (then end) =====
  setStatus('Probing in a single XR frame…', 'ok');

  const oneFrame = new Promise(resolve => {
    session.requestAnimationFrame((t, frame) => {
      try {
        // Viewer pose (inline typically returns a single mono view on Chrome)
        let pose = null;
        if (frame.getViewerPose) {
          // Prefer 'local' if available; else 'viewer'
          pose = refSpace ? frame.getViewerPose(refSpace) : frame.getViewerPose('viewer');
        }

        if (pose) {
          fp['XRViewerPose.views'] = pose.views.length;

          const eyes = [];
          for (const v of pose.views) {
            eyes.push(v.eye || 'unknown');
            // XRWebGLLayer.getViewport (viewport usually equals canvas size in inline)
            const layer = session.renderState?.baseLayer;
            const vp = (layer && layer.getViewport) ? layer.getViewport(v) : null;
            if (vp) fp['XRWebGLLayer.getViewport'] = [vp.x, vp.y, vp.width, vp.height];

            // Non-standard refSpaceFromView (Chrome: usually absent unless incubations)
            fp['XRView.refSpaceFromView'] = (fp['XRView.refSpaceFromView'] === 'present') ? 'present'
              : (('refSpaceFromView' in v) ? 'present' : 'absent');
          }
          fp['XRView.eye'] = eyes;
          row('XRViewerPose.views', true, String(fp['XRViewerPose.views']));
          row('XRView.eye', true, eyes.join(', '));
          row('XRWebGLLayer.getViewport', !!fp['XRWebGLLayer.getViewport'],
              JSON.stringify(fp['XRWebGLLayer.getViewport'] || 'n/a'));
        } else {
          row('getViewerPose', false, 'no pose this frame');
        }

        // Depth (Chrome: present only with flags/devices; we still record shape)
        if (frame.getDepthInformation) {
          const v = pose?.views?.[0];
          const di = v ? frame.getDepthInformation(v) : null;
          if (di) {
            fp['XRDepthInformation.width']  = di.width ?? null;
            fp['XRDepthInformation.height'] = di.height ?? null;
            fp['XRDepthInformation.normDepthBufferFromNormView'] = typeof di.normDepthBufferFromNormView === 'function';
            fp['XRDepthInformation.rawValueToMeters'] = typeof di.rawValueToMeters === 'function';
            row('XRDepthInformation.width/height', true, `${di.width}×${di.height}`);
            row('XRDepthInformation.normDepthBufferFromNormView', !!fp['XRDepthInformation.normDepthBufferFromNormView'], String(fp['XRDepthInformation.normDepthBufferFromNormView']));
            row('XRDepthInformation.rawValueToMeters', !!fp['XRDepthInformation.rawValueToMeters'], String(fp['XRDepthInformation.rawValueToMeters']));
          } else {
            row('XRDepthInformation', false, 'none for this frame');
          }
        } else {
          row('XRDepthInformation', false, 'getDepthInformation absent');
        }

        // Planes (usually absent in inline; record absence explicitly)
        const wi = frame.worldInformation || {};
        if (wi.detectedPlanes && wi.detectedPlanes.size) {
          const first = wi.detectedPlanes.values().next().value;
          if (first) {
            fp['XRPlane.lastChangedTime'] = first.lastChangedTime ?? null;
            fp['XRPlane.planeSpace'] = !!first.planeSpace;
            fp['XRPlane.polygon'] = (first.polygon && first.polygon.length) || 0;
            row('XRPlane.lastChangedTime/planeSpace/polygon', true,
               `t=${first.lastChangedTime} space=${!!first.planeSpace} poly=${(first.polygon||[]).length}`);
          }
        } else {
          row('XRPlane.*', false, 'no planes');
        }

        // Anchors (Chrome mobile with flags; otherwise record capability)
        if (frame.createAnchor && refSpace) {
          // Fire-and-forget creation (no await to keep frame tight)
          try {
            frame.createAnchor(new XRRigidTransform(), refSpace).then(a => {
              fp['XRFrame.createAnchor'] = !!a;
              row('XRFrame.createAnchor', !!a, a ? 'ok' : 'failed');
              if (a?.delete) {
                fp['XRAnchor.Delete'] = true;
                a.delete().catch(()=>{});
                row('XRAnchor.delete', true, 'supported');
              } else {
                row('XRAnchor.delete', false, 'absent');
              }
              finish(fp); // finalize once async completes
            }).catch(e => {
              fp['XRFrame.createAnchor'] = 'threw';
              row('XRFrame.createAnchor', true, 'threw: ' + e);
              finish(fp);
            });
          } catch (e) {
            row('XRFrame.createAnchor', true, 'sync throw: ' + e);
          }
        } else {
          row('XRFrame.createAnchor', false, 'anchors not available');
        }

        // Hit-test (capability + cancel presence)
        if (session.requestHitTestSource) {
          session.requestHitTestSource({ space: refSpace || 'viewer' })
            .then(src => {
              fp['XRHitTestSource.cancel'] = typeof src.cancel === 'function';
              row('XRHitTestSource.cancel', !!fp['XRHitTestSource.cancel'], String(fp['XRHitTestSource.cancel']));
              try { src.cancel?.(); } catch {}
              finish(fp);
            })
            .catch(e => {
              row('XRHitTestSource.cancel', false, 'requestHitTestSource threw: ' + e);
              finish(fp);
            });
        } else {
          row('XRHitTestSource.cancel', false, 'not available');
        }

        // Hand tracking (record size and jointName if available)
        const handSrc = [...(session.inputSources || [])].find(s => s.hand);
        if (handSrc?.hand) {
          const h = handSrc.hand;
          fp['XRHand.size'] = h.size ?? null;
          row('XRHand.size', true, String(h.size));
          const j = h.values().next().value;
          fp['XRJointSpace.jointName'] = j?.jointName ?? null;
          row('XRJointSpace.jointName', j?.jointName != null, String(fp['XRJointSpace.jointName']));
        } else {
          row('XRHand.size / XRJointSpace.jointName', false, 'no hand source');
        }

        // Image tracking (index/state/width/space)
        if (frame.getImageTrackingResults) {
          const results = frame.getImageTrackingResults();
          if (results && results.length) {
            const r = results[0];
            fp['XRImageTrackingResult.index'] = r.index ?? null;
            fp['XRImageTrackingResult.trackingState'] = r.trackingState ?? null;
            fp['XRImageTrackingResult.measuredWidthInMeters'] = r.measuredWidthInMeters ?? null;
            fp['XRImageTrackingResult.imageSpace'] = !!r.imageSpace;
            row('XRImageTrackingResult.*', true,
               `idx=${r.index} state=${r.trackingState} width=${r.measuredWidthInMeters} space=${!!r.imageSpace}`);
          } else {
            row('XRImageTrackingResult.*', false, 'no results');
          }
        } else {
          row('XRImageTrackingResult.*', false, 'absent');
        }

        // Light estimation (direction/intensity/SH coeffs)
        if (frame.getLightEstimate && refSpace) {
          const le = frame.getLightEstimate(refSpace);
          if (le) {
            if ('primaryLightDirection' in le) {
              fp['XRLightEstimate.primaryLightDirection'] = vec3(le.primaryLightDirection);
              row('XRLightEstimate.primaryLightDirection', true, String(fp['XRLightEstimate.primaryLightDirection']));
            }
            if ('primaryLightIntensity' in le) {
              const v = le.primaryLightIntensity ?? null;
              fp['XRLightEstimate.primaryLightIntensity'] = v ? Array.from(v) : null;
              row('XRLightEstimate.primaryLightIntensity', !!v, v ? `${v.length} chan` : 'null');
            }
            if ('sphericalHarmonicsCoefficients' in le) {
              const sh = le.sphericalHarmonicsCoefficients ?? null;
              fp['XRLightEstimate.sphericalHarmonicsCoefficients'] = sh ? Array.from(sh) : null;
              row('XRLightEstimate.sphericalHarmonicsCoefficients', !!sh, sh ? `${sh.length} coeffs` : 'null');
            }
          } else {
            row('XRLightEstimate.*', false, 'no estimate this frame');
          }
        } else {
          row('XRLightEstimate.*', false, 'absent');
        }

        // XRGPUBinding (record presence/shape even if not usable)
        if ('XRGPUBinding' in window) {
          fp['XRGPUBinding.getViewSubImage'] = protoHas(XRGPUBinding, 'getViewSubImage');
          row('XRGPUBinding.getViewSubImage', !!fp['XRGPUBinding.getViewSubImage'], String(fp['XRGPUBinding.getViewSubImage']));
        } else {
          row('XRGPUBinding.getViewSubImage', false, 'XRGPUBinding absent');
        }
      } finally {
        // End promptly; finish(fp) will run once pending async checks resolve
        session.end().catch(()=>{});
      }
    });
  });

  // Safety timeout to finalize even if promises don’t resolve
  await Promise.race([oneFrame, new Promise(r => setTimeout(r, 1200))]);
  // If finish() already ran, it’s a no-op; otherwise finalize now:
  finish(fp);
}

let finished = false;
function finish(fp) {
  if (finished) return;
  finished = true;

  // Mark missing items from the user’s list explicitly if not set:
  const keysWanted = [
    'XRAnchor.Delete',
    'XRDepthInformation.height',
    'XRDepthInformation.normDepthBufferFromNormView',
    'XRDepthInformation.rawValueToMeters',
    'XRDepthInformation.width',
    'XRFrame.createAnchor',
    'XRGPUBinding.getViewSubImage',
    'XRHand.size',
    'XRHitTestSource.cancel',
    'XRImageTrackingResult.imageSpace',
    'XRImageTrackingResult.index',
    'XRImageTrackingResult.measuredWidthInMeters',
    'XRImageTrackingResult.trackingState',
    'XRJointSpace.jointName',
    'XRLightEstimate.primaryLightDirection',
    'XRLightEstimate.primaryLightIntensity',
    'XRLightEstimate.sphericalHarmonicsCoefficients',
    'XRPlane.lastChangedTime',
    'XRPlane.planeSpace',
    'XRPlane.polygon',
    'XRRay.direction',
    'XRRay.matrix',
    'XRRay.origin',
    'XRRigidTransform.inverse',
    'XRRigidTransform.orientation',
    'XRRigidTransform.position',
    'XRSession.updateRenderState',
    'XRView.eye',
    'XRView.refSpaceFromView',
    'XRViewerPose.views',
    'XRWebGLLayer.getViewport'
  ];
  for (const k of keysWanted) if (!(k in fp)) fp[k] = 'unavailable';

  // Basic “entropy” proxy: number of defined (non-"unavailable") keys + JSON length
  const defined = Object.entries(fp).filter(([_,v]) => v !== 'unavailable' && v !== false && v != null).length;
  const json = JSON.stringify(fp, (k,v) => (Array.isArray(v) && v.length>64 ? `[len=${v.length}]` : v), 2);
  const h = djb2(json);
  rawEl.textContent = json;
  hashEl.textContent = h;
  summaryEl.textContent = `Signals defined: ${defined}/${keysWanted.length} • JSON bytes: ${json.length} • hash: ${h}`;
  setStatus('Done. Compare the hash across devices/runs to see stability/variance.', 'ok');
}

runBtn.addEventListener('click', () => {
  finished = false;
  start().catch(e => {
    setStatus('Unexpected error: ' + e, 'no');
    runBtn.disabled = false;
  }).finally(() => {
    runBtn.disabled = false;
  });
});
</script>
