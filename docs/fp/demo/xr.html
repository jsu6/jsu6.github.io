<!doctype html>
<meta charset="utf-8" />
<title>WebXR Fingerprinting Proof of Concept</title>
<style>
  body { font-family: system-ui, -apple-system, sans-serif; padding: 1rem; max-width: 1000px; margin: auto; }
  button { padding: .5rem .9rem; margin-right: .4rem; }
  table { border-collapse: collapse; margin-top: 1rem; width: 100%; }
  th, td { border: 1px solid #ccc; padding: .4rem .6rem; text-align: left; }
  th { background: #f3f3f3; }
  .ok { color: #008000; }
  .err { color: #b00020; }
  .warn { color: #a15a00; }
  #status { margin-left: .5rem; }
  pre { background: #fafafa; padding: .8rem; border: 1px solid #eee; overflow: auto; }
</style>

<h1>WebXR Fingerprinting Proof of Concept</h1>
<p>
  This demo probes WebXR interfaces and shows how their presence, numeric values, or errors
  can serve as potential fingerprinting signals, even without real XR hardware.
</p>
<button id="run">Run</button>
<button id="copy">Copy JSON</button>
<span id="status"></span>
<div id="results"></div>
<pre id="raw"></pre>

<script>
(async () => {
  const status = document.getElementById("status");
  const resultsEl = document.getElementById("results");
  const raw = document.getElementById("raw");
  const setStatus = (t, cls="") => { status.textContent = t; status.className = cls; };

  function safe(fn) {
    try {
      const v = fn();
      if (v && typeof v.then === "function") return v.then(val => ({ok:true,value:val}))
        .catch(e => ({ok:false,error:String(e),name:e?.name}));
      return {ok:true,value:v};
    } catch(e){ return {ok:false,error:String(e),name:e?.name}; }
  }

  async function run() {
    setStatus("Running…","warn");
    const res = { env:{ ua:navigator.userAgent, platform:navigator.platform }, fp:[], raw:{} };

    if(!navigator.xr){
      res.fp.push({api:"navigator.xr",status:"missing",value:"",impact:"high"});
      finalize(res); return;
    }

    const inlineSupported = await navigator.xr.isSessionSupported("inline").catch(()=>false);
    res.fp.push({api:"isSessionSupported(inline)",status:inlineSupported?"ok":"fail",impact:"high"});

    if(!inlineSupported){ finalize(res); return; }

    const sessionReq = await safe(()=>navigator.xr.requestSession("inline",{optionalFeatures:[
      "anchors","hit-test","hand-tracking","light-estimation","plane-detection","depth-sensing","image-tracking"
    ]}));
    if(!sessionReq.ok){ res.fp.push({api:"requestSession",status:"error",value:sessionReq.error,impact:"high"}); finalize(res); return; }
    const session=sessionReq.value;

    const refSpaceReq = await safe(()=>session.requestReferenceSpace("viewer"));
    const refSpace = refSpaceReq.ok?refSpaceReq.value:null;

    const canvas=document.createElement("canvas");
    const gl=canvas.getContext("webgl",{xrCompatible:true});
    await gl?.makeXRCompatible?.();
    const layer=new XRWebGLLayer(session,gl);
    session.updateRenderState({baseLayer:layer});

    // Quick constructor fingerprints
    if("XRRay" in window){
      const r=new XRRay();
      res.fp.push({api:"XRRay.matrix.length",status:"ok",value:r.matrix.length,impact:"low"});
    } else res.fp.push({api:"XRRay",status:"missing",impact:"low"});

    if("XRRigidTransform" in window){
      const t=new XRRigidTransform();
      res.fp.push({api:"XRRigidTransform.inverse",status:t.inverse?"ok":"missing",impact:"medium"});
    }

    // one frame only
    session.requestAnimationFrame(async (time,frame)=>{
      try{
        const pose=frame.getViewerPose(refSpace);
        if(pose){
          res.fp.push({api:"XRView.eye",status:"ok",value:pose.views[0]?.eye,impact:"medium"});
          const vp=layer.getViewport(pose.views[0]);
          res.fp.push({api:"XRWebGLLayer.getViewport",status:"ok",value:`${vp.width}x${vp.height}`,impact:"high"});
        } else res.fp.push({api:"getViewerPose",status:"fail",impact:"high"});

        // Depth
        try{
          const d=frame.getDepthInformation?.(pose?.views?.[0]);
          if(d) res.fp.push({api:"XRDepthInformation",status:"ok",
              value:`${d.width}×${d.height}`,impact:"high"});
          else res.fp.push({api:"XRDepthInformation",status:"missing",impact:"high"});
        }catch(e){ res.fp.push({api:"XRDepthInformation",status:"error",value:String(e),impact:"high"}); }

        // Anchor
        if(frame.createAnchor && refSpace){
          const a=await safe(()=>frame.createAnchor(new XRRigidTransform(),refSpace));
          res.fp.push({api:"XRFrame.createAnchor",status:a.ok?"ok":"fail",impact:"medium"});
        }

        // Hand/joints
        try{
          const src=session.inputSources.find(s=>s.hand);
          res.fp.push({api:"XRHand",status:src?"ok":"none",impact:"medium"});
          if(src?.hand) res.fp.push({api:"XRHand.size",status:"ok",value:src.hand.size,impact:"low"});
        }catch(e){res.fp.push({api:"XRHand",status:"error",value:String(e),impact:"medium"});}

        // Plane detection
        try{
          const planes=frame.worldInformation?.detectedPlanes;
          res.fp.push({api:"XRPlane",status:planes?"ok":"none",impact:"medium"});
          const p=planes?.values().next().value;
          if(p) res.fp.push({api:"XRPlane.polygon.length",status:"ok",value:p.polygon?.length,impact:"low"});
        }catch(e){res.fp.push({api:"XRPlane",status:"error",value:String(e),impact:"medium"});}

        await session.end();
        finalize(res);
      }catch(e){
        res.fp.push({api:"frame",status:"error",value:String(e),impact:"high"});
        await session.end();
        finalize(res);
      }
    });
  }

  function finalize(res){
    setStatus("Finished.","ok");
    const rows = res.fp.map(r=>`
      <tr>
        <td>${r.api}</td>
        <td class="${r.status==='ok'?'ok':r.status==='error'?'err':'warn'}">${r.status}</td>
        <td>${r.value??''}</td>
        <td>${r.impact}</td>
      </tr>`).join("");
    resultsEl.innerHTML = `
      <h3>Fingerprinting Signals</h3>
      <table>
        <tr><th>API</th><th>Status</th><th>Value / Error</th><th>Entropy Impact</th></tr>
        ${rows}
      </table>`;
    raw.textContent = JSON.stringify(res, null, 2);
  }

  document.getElementById("run").onclick = run;
  document.getElementById("copy").onclick = async ()=>{
    try{ await navigator.clipboard.writeText(raw.textContent);
      setStatus("Copied JSON","ok"); }catch{ setStatus("Copy failed","warn"); }
  };
})();
</script>
