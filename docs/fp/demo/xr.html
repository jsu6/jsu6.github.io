<!doctype html>
<meta charset="utf-8" />
<title>WebXR PoC (Chromium-safe, one frame)</title>
<style>
  body { font-family: system-ui; padding: 1rem; max-width: 900px; margin:auto; }
  button { padding: .4rem .8rem; margin-right: .4rem; }
  pre { background:#f6f7f9; border:1px solid #ccc; padding:.8rem; overflow:auto; }
</style>

<h2>WebXR Proof of Concept (safe single-frame)</h2>
<p>This demo requests an inline XR session, probes key APIs, and exits cleanly.
Works even without XR hardware.</p>
<button id="run">Run</button>
<button id="copy">Copy JSON</button>
<span id="status"></span>
<pre id="out">Ready.</pre>

<script>
(async () => {
  const out = document.getElementById("out");
  const status = document.getElementById("status");
  const setStatus = (t,c="") => { status.textContent=t; status.className=c; };
  const log = (o) => { out.textContent = JSON.stringify(o,null,2); };

  function safe(fn) {
    try {
      const v = fn();
      if (v && typeof v.then==="function")
        return v.then(val=>({ok:true,value:val})).catch(e=>({ok:false,error:String(e)}));
      return {ok:true,value:v};
    } catch(e) { return {ok:false,error:String(e)}; }
  }

  function exists(name) { return (name in globalThis); }

  async function run() {
    setStatus("Running...");
    const res = { env:{ua:navigator.userAgent}, support:{}, values:{}, errors:{} };

    if(!navigator.xr) {
      res.errors.noXR = "navigator.xr not found";
      log(res); setStatus("Done (no XR).","ok"); return;
    }

    const inline = await navigator.xr.isSessionSupported("inline").catch(()=>false);
    if(!inline){ res.errors.noInline="inline not supported"; log(res); setStatus("Done.","ok"); return; }

    const sess = await navigator.xr.requestSession("inline",{optionalFeatures:[
      "anchors","hit-test","hand-tracking","light-estimation","plane-detection","depth-sensing","image-tracking"
    ]}).catch(e=>({error:String(e)}));
    if(!sess || sess.error){ res.errors.session=String(sess.error||"fail"); log(res); setStatus("Done.","ok"); return; }

    let refSpace=null;
    try{ refSpace=await sess.requestReferenceSpace("viewer"); }catch{}

    // WebGL setup
    const canvas=document.createElement("canvas");
    const gl=canvas.getContext("webgl",{xrCompatible:true});
    await gl?.makeXRCompatible?.();
    const layer=new XRWebGLLayer(sess,gl);
    sess.updateRenderState({baseLayer:layer});

    // Constructor-only probes (no session)
    res.values.XRRay = exists("XRRay") ? (()=>{const r=new XRRay();return{
      origin:r.origin, direction:r.direction, matrix:Array.from(r.matrix)}})() : null;
    res.values.XRRigidTransform = exists("XRRigidTransform") ? (()=>{const t=new XRRigidTransform();
      return{pos:t.position,orient:t.orientation,inv:!!t.inverse}})() : null;

    // One frame only
    const frameHandle = sess.requestAnimationFrame(async (t,frame)=>{
      try{
        const pose = frame.getViewerPose(refSpace);
        res.support.viewerPose = !!pose;
        if(pose?.views?.length){
          const view = pose.views[0];
          const vp = layer.getViewport(view);
          res.values.viewport = vp ? {x:vp.x,y:vp.y,w:vp.width,h:vp.height}:null;
          res.values.eye = view.eye;
        }

        // Depth Info
        try{
          const depth = frame.getDepthInformation?.(pose?.views?.[0]);
          if(depth){
            res.values.depth = {
              w:depth.width,h:depth.height,
              raw1: depth.rawValueToMeters?.(1)??null
            };
          }
        }catch(e){ res.errors.depth=String(e); }

        // Anchor test
        if(frame.createAnchor && refSpace){
          const a = await safe(()=>frame.createAnchor(new XRRigidTransform(),refSpace));
          res.support.anchor = a.ok;
          if(a.ok) await safe(()=>a.value.delete());
        }

        await sess.end().catch(()=>{});
        cancelAnimationFrame(frameHandle);
        setStatus("Finished.","ok");
        log(res);
      }catch(e){
        res.errors.frame=String(e);
        await sess.end().catch(()=>{});
        cancelAnimationFrame(frameHandle);
        setStatus("Finished (error).","warn");
        log(res);
      }
    });
  }

  document.getElementById("run").onclick = run;
  document.getElementById("copy").onclick = async ()=>{
    try{ await navigator.clipboard.writeText(out.textContent);
      setStatus("Copied JSON","ok"); }catch{ setStatus("Copy failed","warn"); }
  };
})();
</script>
